# CppCon 2023 Lightning Talk Repo

See [this blog post](https://vasuagrawal.com/2023/10/making-friends-with-cuda-programmers/) for more details.

## Disclaimer

Unfortuntely, VSCode seems to not automatically save Jupyter notebooks when you run them, so the `combine_outputs.ipynb` file is empty. Same goes for the `notes.md` file - VSCode doesn't prompt me (at least by default) to save any files when I close it, as I guess it'll just hold on to the buffer in its own memory somewhere. This might work fine for local use, but it doesn't play nicely with SSH remote connections, where the PC on the other end might not exist later (in the case of ephemeral servers, like what I used here).

In other words, the only useful bit of code here is the `constexpr.py` script.

## Usage

First, clone any repos you want, likely into a subfolder. I used a `cloned_repos` subfolder. Some examples:
* [GCC](https://github.com/gcc-mirror/gcc)
* [TensorFlow](https://github.com/tensorflow/tensorflow)
* [OpenCV](https://github.com/opencv/opencv)
* etc (see `outputs` folder for more repo names)

Then, run the `constexpr.py` script:

```bash
# See usage
$ constexpr.py --help

# Run on everything in your cloned_repos folder
$ constexpr.py cloned_repos/*

# Or just a couple repos to test with
$ constexpr.py cloned_repos/gcc cloned_repos/tensorflow
```

All of the output will be saved to an `outputs` folder in this repo. This **folder must exist beforehand**, so create it yourself.

This would be the part where I'd say use the `combine_outputs.ipynb` notebook to merge the various outputs into a single CSV, but as noted above the script is gone. Take my word for it that the only thing happening in the script was merging some columns together, and converting unix times to fractional years. There's no data manipulation going on. The merged outputs are linked in the blog post, anyway, and in `combined2k.csv`.

## Thoughts / Methodology

I ended up spending way more time generating the `constexpr` keyword count plots than I wanted. I thought it'd originally be as simple as "clone repo, run grep, checkout previous version" ... but that couldn't be further from the truth. I hit a couple issues:

### Submodules
These were probably the biggest pain, and also probably the biggest source of error in the counting. In hindsight, I probably should've just not cloned the submodules at all, and counted only the code in the base repo. The main issue here came from attempting to check out submodules from years ago - often, the upstream source for the submodule simply doesn't exist anymore (or is now private or something), and my checkout fails. I think I also hit issues with not completely cleanly checking out the correct version of the submodule repo, resulting in newer files still existing (instead of being deleted, like I wanted) as I went back in commit history. This all resulted in me counting way more stuff than necessary for some repos, and possibly terminating early for a given repo once its submodules stopped cloning.

### Multiple parents

As [this StackOverflow answer points out](https://stackoverflow.com/a/1007545), there can actually be multiple "initial" commits for a given repo. This can happen if multiple repos get merged together. I don't think this necessarily results in _correctness_ issues, but if you end up with some sort of zipper merge of multiple repos (with commits over time merged into a single timeline), then you'll also end up with a zipper effect in the plots, which might explain some of the weirdness for the LLVM plot.

### How / what to count?

Even if we ignore the submodule issue from above, this still leaves a few other code-related issues. Since my goal was primarily to show off `constexpr` adoption in standard libraries, I _probably_ should've only considered `constexpr` in header files, rather than the entire repo. This would run into its own problems, though, because I think headers may sometimes get autogenerated as part of a build step (which I didn't run at all), or have weird extensions (think modules, which are kind of "headers"). It's also not immediately obvious which folders in the repo I should be considering. I should, of course, exclude test / documentation / etc folders, and only look for `include`, `src`, etc folders, but there's no consistent conventions for those across all codebases, and I didn't want to hardcode values for each repo and end up missing something.

### Screw it

I ended up going for the fairly simple approach of "include all the inital commits", "count all the code (without generation)", and "skip failures (e.g. submodule checkout)". As discussed above, this is definitely suboptimal, but the important thing was that the overall trend in the plots was in the direction I wanted it to be. Definitely not good science (stopping your experiment when the data looks the way you expect) ... but since there's at least _some_ repos in the ~15 that I used which probably didn't suffer from most of these issues, but still demonstrated the same trend, I'll say that the results are still largely correct. Or at least, the overall trend is. More `constexpr` everywhere! 